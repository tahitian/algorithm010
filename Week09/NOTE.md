## 第九周学习总结


### 高级动态规划

动态规划：分治 + 最优子结构

顺推形式：动态递推

#### DP 顺推模板

```
function DP():
dp = [][] # 二维情况
  for i = 0 .. M {
    for j = 0 .. N {
       dp[i][j] = _Function(dp[i’][j’]...)
    }
  }
  return dp[M][N];
```

#### 和分治的比较

共同点：递归，也就是找到重复子问题

不同点：动态规划有最优子结构，可以在中途淘汰次优解

#### 高级动态规划复杂度的来源

1. 状态拥有更多维度(二维、三维、或者更多、甚至需要压缩)
2. 状态方程更加复杂


### 字符串匹配算法

暴力法，时间复杂度 O(m*n)

#### Rabin-Karp 算法

1. 假设子串的长度为 M (pat)，目标字符串的长度为 N (txt)
2. 计算子串的 hash 值 hash_pat
3. 计算目标字符串txt中每个长度为 M 的子串的 hash 值(共需要计算 N-M+1 次)
4. 比较 hash 值: 如果 hash 值不同，字符串必然不匹配; 如果 hash 值相同， 还需要使用朴素算法再次判断

#### KMP 算法

此算法通过运用对这个词在不匹配时本身就包含足够的信息来确定下一个匹配将在哪里开始的发现，从而避免重新检查先前匹配的字符。

假设现在文本串 S 匹配到 i 位置，模式串 P 匹配到 j 位置
- 如果 j = -1，或者当前字符匹配成功（即 S[i] == P[j]），都令 i++，j++，继续匹配下一个字符；
- 如果 j != -1，且当前字符匹配失败（即 S[i] != P[j]），则令 i 不变，j = next[j]。此举意味着失配时，模式串 P 相对于文本串 S 向右移动了 j - next [j] 位
    - 换言之，当匹配失败时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的 next 值，即移动的实际位数为：j - next[j]，且此值大于等于1